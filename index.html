<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Soliloquy English</title>
    <style>
        :root {
            --primary: #007aff;
            --success: #34c759;
            --warning: #ff9500;
            --danger: #ff3b30;
            --bg: #f5f5f7;
            --card-bg: #ffffff;
            --text: #1d1d1f;
            --text-secondary: #86868b;
            --border: #d2d2d7;
        }
        * { box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg);
            margin: 0;
            padding: 16px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }
        .container { width: 100%; max-width: 500px; }

        /* Settings */
        .settings {
            margin-bottom: 16px;
            background: var(--card-bg);
            border-radius: 12px;
            padding: 12px;
        }
        .settings input {
            width: 100%;
            padding: 10px;
            border-radius: 8px;
            border: 1px solid var(--border);
            font-size: 14px;
            background: var(--bg);
            margin-top: 8px;
        }
        .settings summary {
            font-size: 14px;
            color: var(--text-secondary);
            cursor: pointer;
        }

        /* Main recording section */
        .main-section {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 24px;
            margin-bottom: 16px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        /* Fixed bottom record area */
        .record-area {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 16px;
            padding-bottom: max(16px, env(safe-area-inset-bottom));
            background: var(--card-bg);
            box-shadow: 0 -2px 10px rgba(0,0,0,0.1);
            z-index: 100;
        }
        #mainBtn {
            background: var(--primary);
            color: white;
            border: none;
            width: 72px;
            height: 72px;
            border-radius: 50%;
            font-size: 28px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }
        #mainBtn.recording {
            background: var(--danger);
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(255,59,48,0.5);
        }
        #mainBtn:disabled {
            background: var(--text-secondary);
            cursor: not-allowed;
        }
        #status {
            margin-top: 8px;
            font-size: 13px;
            color: var(--text-secondary);
            text-align: center;
        }
        /* Bottom padding for fixed button */
        .container {
            padding-bottom: 120px;
        }

        /* State badge */
        .state-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            margin-bottom: 16px;
        }
        .state-badge.idle { background: #e5e5ea; color: var(--text-secondary); }
        .state-badge.recording { background: #ffe5e5; color: var(--danger); }
        .state-badge.transcribing { background: #fff3e5; color: var(--warning); }
        .state-badge.confirming { background: #e5f0ff; color: var(--primary); }
        .state-badge.correcting { background: #fff3e5; color: var(--warning); }
        .state-badge.suggesting { background: #e5ffe5; color: var(--success); }

        /* Text area */
        .text-section { margin-bottom: 16px; }
        .text-section label {
            font-size: 11px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            display: block;
            margin-bottom: 6px;
        }
        #transcriptArea {
            width: 100%;
            min-height: 80px;
            padding: 12px;
            border: 2px solid var(--border);
            border-radius: 8px;
            font-size: 16px;
            font-family: inherit;
            resize: vertical;
            transition: border-color 0.2s;
        }
        #transcriptArea:focus {
            outline: none;
            border-color: var(--primary);
        }
        #transcriptArea:disabled {
            background: var(--bg);
            color: var(--text-secondary);
        }

        /* Action buttons */
        .action-buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .action-btn {
            padding: 10px 16px;
            border-radius: 8px;
            border: none;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: all 0.2s;
        }
        .action-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .action-btn.primary { background: var(--primary); color: white; }
        .action-btn.success { background: var(--success); color: white; }
        .action-btn.warning { background: var(--warning); color: white; }
        .action-btn.danger { background: var(--danger); color: white; }
        .action-btn.secondary { background: var(--bg); color: var(--text); border: 1px solid var(--border); }

        /* AI Suggestion panel */
        .suggestion-panel {
            background: linear-gradient(135deg, #e8f5e9 0%, #f1f8e9 100%);
            border-radius: 12px;
            padding: 16px;
            margin-top: 16px;
            display: none;
        }
        .suggestion-panel.visible { display: block; }
        .suggestion-panel h4 {
            margin: 0 0 8px 0;
            font-size: 13px;
            color: var(--success);
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .suggestion-text {
            font-size: 16px;
            color: var(--text);
            cursor: pointer;
            padding: 8px;
            background: white;
            border-radius: 8px;
            margin-bottom: 8px;
        }
        .suggestion-text:hover { background: #f0f0f0; }

        /* Intent input */
        .intent-section {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid rgba(0,0,0,0.1);
        }
        .intent-section label {
            font-size: 12px;
            color: var(--text-secondary);
            display: block;
            margin-bottom: 8px;
        }

        /* History */
        .history-section {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 16px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .history-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid var(--border);
        }
        .history-header h3 { margin: 0; font-size: 16px; }
        .clear-btn {
            font-size: 12px;
            color: var(--danger);
            cursor: pointer;
            background: none;
            border: none;
        }

        .history-item {
            padding: 12px 0;
            border-bottom: 1px solid var(--bg);
        }
        .history-item:last-child { border-bottom: none; }
        .history-item-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }
        .history-item-content { flex: 1; }
        .history-label {
            font-size: 10px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            margin-bottom: 2px;
        }
        .history-original { font-size: 14px; color: var(--text-secondary); margin-bottom: 4px; }
        .history-final { font-size: 15px; color: var(--text); margin-bottom: 4px; }
        .history-suggestion {
            font-size: 15px;
            color: var(--primary);
            font-weight: 500;
            cursor: pointer;
        }
        .notion-btn {
            background: none;
            border: 1px solid var(--border);
            border-radius: 4px;
            width: 28px;
            height: 28px;
            font-size: 12px;
            cursor: pointer;
            color: var(--text-secondary);
            flex-shrink: 0;
            margin-left: 8px;
        }
        .notion-btn.saved {
            color: var(--success);
            border-color: var(--success);
            cursor: default;
        }

        /* Empty state */
        .empty-state {
            text-align: center;
            padding: 24px;
            color: var(--text-secondary);
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Settings (collapsible) -->
        <details class="settings">
            <summary>Settings</summary>
            <input type="password" id="apiKey" placeholder="OpenAI API Key">
            <input type="password" id="notionToken" placeholder="Notion Integration Token">
            <input type="text" id="notionDbId" placeholder="Notion Database ID">
        </details>

        <!-- Main Section -->
        <div class="main-section">
            <div style="text-align: center;">
                <span class="state-badge idle" id="stateBadge">IDLE</span>
            </div>

            <div class="text-section">
                <label>Ë™çË≠òÁµêÊûú / Your English</label>
                <textarea id="transcriptArea" placeholder="Èå≤Èü≥„Åô„Çã„Å®Ë™çË≠òÁµêÊûú„Åå„Åì„Åì„Å´Ë°®Á§∫„Åï„Çå„Åæ„Åô..." disabled></textarea>
            </div>

            <div class="action-buttons" id="actionButtons">
                <button class="action-btn warning" id="btnVoiceCorrect" disabled title="Êó•Êú¨Ë™û„Åß‰øÆÊ≠£ÊåáÁ§∫">
                    üé§ Èü≥Â£∞‰øÆÊ≠£
                </button>
                <button class="action-btn success" id="btnComplete" disabled title="AI„Å´Ëá™ÁÑ∂„Å™Ë°®Áèæ„ÇíËÅû„Åè">
                    ‚úì ÂÆå‰∫Ü
                </button>
                <button class="action-btn secondary" id="btnRetry" disabled title="ÊúÄÂàù„Åã„Çâ„ÇÑ„ÇäÁõ¥„Åô">
                    ‚Ü©Ô∏è „ÇÑ„ÇäÁõ¥„Åó
                </button>
            </div>

            <!-- AI Suggestion Panel -->
            <div class="suggestion-panel" id="suggestionPanel">
                <h4>üí° AI's Suggestion</h4>
                <div class="suggestion-text" id="suggestionText" onclick="speakSuggestion()"></div>
                <div class="suggestion-explanation" id="suggestionExplanation" style="font-size: 13px; color: var(--text-secondary); padding: 8px; background: rgba(0,0,0,0.03); border-radius: 8px; margin-bottom: 8px; display: none;"></div>
                <div class="action-buttons">
                    <button class="action-btn primary" id="btnAccept">Êé°Áî®„Åó„Å¶‰øùÂ≠ò</button>
                    <button class="action-btn secondary" id="btnKeepOriginal">ÂÖÉ„ÅÆ„Åæ„Åæ‰øùÂ≠ò</button>
                </div>

                <div class="intent-section">
                    <label>‰ºù„Çè„Çâ„Å™„Åã„Å£„ÅüÂ†¥Âêà„ÅØÊó•Êú¨Ë™û„ÅßÊÑèÂõ≥„ÇíË™¨Êòé</label>
                    <div class="intent-display" id="intentDisplay" style="display: none; padding: 8px; background: #fff3e5; border-radius: 8px; margin-bottom: 8px; font-size: 14px;"></div>
                    <button class="action-btn warning" id="btnResuggestion" style="width: 100%;">üé§ Èü≥Â£∞„ÅßÊÑèÂõ≥„ÇíË™¨Êòé„Åó„Å¶ÂÜçÊèêÊ°à</button>
                </div>
            </div>
        </div>

        <!-- History -->
        <div class="history-section">
            <div class="history-header">
                <h3>Â±•Ê≠¥</h3>
                <button class="clear-btn" onclick="clearHistory()">Clear all</button>
            </div>
            <div id="historyList">
                <div class="empty-state">„Åæ„Å†Â±•Ê≠¥„Åå„ÅÇ„Çä„Åæ„Åõ„Çì</div>
            </div>
        </div>
    </div>

    <!-- Fixed bottom record button -->
    <div class="record-area">
        <button id="mainBtn">üé§</button>
        <div id="status">Ëã±Ë™û„ÅßË©±„Åó„Å¶„Åø„Åæ„Åó„Çá„ÅÜ</div>
    </div>

    <script>
        // ===== State Management =====
        const AppState = {
            IDLE: 'idle',
            RECORDING: 'recording',
            TRANSCRIBING: 'transcribing',
            CONFIRMING: 'confirming',
            CORRECTING: 'correcting',
            SUGGESTING: 'suggesting'
        };

        let currentState = AppState.IDLE;
        let currentData = {
            original: '',
            final: '',
            aiSuggestion: '',
            aiExplanation: '',
            intentNote: ''
        };

        // ===== Audio Context & Recording =====
        let mediaRecorder = null;
        let audioChunks = [];
        let audioStream = null;
        let audioCtx = null;
        let recordingMode = 'english'; // 'english': Ëã±Ë™ûÈå≤Èü≥, 'correction': Êó•Êú¨Ë™û‰øÆÊ≠£, 'intent': ÊÑèÂõ≥Ë™¨Êòé

        // ===== DOM Elements =====
        const mainBtn = document.getElementById('mainBtn');
        const stateBadge = document.getElementById('stateBadge');
        const statusText = document.getElementById('status');
        const transcriptArea = document.getElementById('transcriptArea');
        const btnVoiceCorrect = document.getElementById('btnVoiceCorrect');
        const btnComplete = document.getElementById('btnComplete');
        const btnRetry = document.getElementById('btnRetry');
        const suggestionPanel = document.getElementById('suggestionPanel');
        const suggestionText = document.getElementById('suggestionText');
        const intentDisplay = document.getElementById('intentDisplay');
        const btnAccept = document.getElementById('btnAccept');
        const btnKeepOriginal = document.getElementById('btnKeepOriginal');
        const btnResuggestion = document.getElementById('btnResuggestion');
        const historyList = document.getElementById('historyList');

        // ===== Utility Functions =====
        function fetchWithTimeout(url, options, ms = 30000) {
            const controller = new AbortController();
            const timer = setTimeout(() => controller.abort(), ms);
            return fetch(url, { ...options, signal: controller.signal })
                .finally(() => clearTimeout(timer));
        }

        async function initAudioContext() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (audioCtx.state === 'suspended') {
                await audioCtx.resume();
            }
        }

        async function playAudioBlob(blob) {
            await initAudioContext();
            const arrayBuffer = await blob.arrayBuffer();
            const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
            const source = audioCtx.createBufferSource();
            source.buffer = audioBuffer;
            source.connect(audioCtx.destination);
            source.start();
            return new Promise(resolve => { source.onended = resolve; });
        }

        function stopStream() {
            if (audioStream) {
                audioStream.getTracks().forEach(track => track.stop());
                audioStream = null;
            }
        }

        function getApiKey() {
            return document.getElementById('apiKey').value;
        }

        function hasNotionConfig() {
            return !!(localStorage.getItem('notionToken') && localStorage.getItem('notionDbId'));
        }

        // ===== State Management =====
        function setState(newState) {
            currentState = newState;
            stateBadge.className = `state-badge ${newState}`;
            stateBadge.textContent = newState.toUpperCase();
            updateUI();
        }

        function updateUI() {
            const isIdle = currentState === AppState.IDLE;
            const isRecording = currentState === AppState.RECORDING;
            const isConfirming = currentState === AppState.CONFIRMING;
            const isCorrecting = currentState === AppState.CORRECTING;
            const isSuggesting = currentState === AppState.SUGGESTING;

            // Main button
            mainBtn.classList.toggle('recording', isRecording);
            mainBtn.textContent = isRecording ? '‚ñ†' : 'üé§';
            mainBtn.disabled = currentState === AppState.TRANSCRIBING || isSuggesting;

            // Transcript area
            transcriptArea.disabled = !(isConfirming || isCorrecting);

            // Action buttons
            btnVoiceCorrect.disabled = !(isConfirming || isCorrecting);
            btnComplete.disabled = !(isConfirming || isCorrecting);
            btnRetry.disabled = isIdle || isRecording;

            // Suggestion panel
            suggestionPanel.classList.toggle('visible', isSuggesting);
        }

        function resetToIdle() {
            currentData = { original: '', final: '', aiSuggestion: '', aiExplanation: '', intentNote: '' };
            transcriptArea.value = '';
            intentDisplay.textContent = '';
            intentDisplay.style.display = 'none';
            suggestionText.textContent = '';
            document.getElementById('suggestionExplanation').style.display = 'none';
            setState(AppState.IDLE);
            statusText.textContent = 'Ëã±Ë™û„ÅßË©±„Åó„Å¶„Åø„Åæ„Åó„Çá„ÅÜ';
        }

        // ===== Recording Functions =====
        // mode: 'english' | 'correction' | 'intent'
        async function startRecording(mode = 'english') {
            const key = getApiKey();
            if (!key) {
                alert('OpenAI API Key„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ');
                return;
            }

            await initAudioContext();

            try {
                stopStream();
                audioStream = await navigator.mediaDevices.getUserMedia({
                    audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: true }
                });

                const mimeType = MediaRecorder.isTypeSupported('audio/webm;codecs=opus')
                    ? 'audio/webm;codecs=opus' : 'audio/mp4';
                mediaRecorder = new MediaRecorder(audioStream, { mimeType });

                audioChunks = [];
                recordingMode = mode;

                mediaRecorder.ondataavailable = e => {
                    if (e.data.size > 0) audioChunks.push(e.data);
                };

                mediaRecorder.onstop = async () => {
                    stopStream();
                    const blob = new Blob(audioChunks, { type: mediaRecorder.mimeType });

                    if (blob.size < 1000) {
                        statusText.textContent = 'Èü≥Â£∞„ÅåÁü≠„Åô„Åé„Åæ„Åô';
                        if (recordingMode === 'intent') {
                            setState(AppState.SUGGESTING);
                        } else {
                            setState(currentData.original ? AppState.CONFIRMING : AppState.IDLE);
                        }
                        return;
                    }

                    if (recordingMode === 'english') {
                        await processEnglishRecording(blob, mimeType);
                    } else if (recordingMode === 'correction') {
                        await processJapaneseCorrection(blob, mimeType);
                    } else if (recordingMode === 'intent') {
                        await processIntentRecording(blob, mimeType);
                    }
                };

                mediaRecorder.start();
                setState(AppState.RECORDING);
                const messages = {
                    'english': 'Ëã±Ë™û„ÅßË©±„Åó„Å¶„Åè„Å†„Åï„ÅÑ...',
                    'correction': 'Êó•Êú¨Ë™û„Åß‰øÆÊ≠£ÊåáÁ§∫„Çí...',
                    'intent': 'Êó•Êú¨Ë™û„ÅßÊÑèÂõ≥„ÇíË™¨Êòé„Åó„Å¶„Åè„Å†„Åï„ÅÑ...'
                };
                statusText.textContent = messages[mode];

            } catch (e) {
                alert('„Éû„Ç§„ÇØ„Ç®„É©„Éº: ' + e.message);
                statusText.textContent = '„Éû„Ç§„ÇØ„Å∏„ÅÆ„Ç¢„ÇØ„Çª„Çπ„ÅåÊãíÂê¶„Åï„Çå„Åæ„Åó„Åü';
            }
        }

        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
            }
        }

        // ===== Processing Functions =====
        async function processEnglishRecording(blob, mimeType) {
            setState(AppState.TRANSCRIBING);
            statusText.textContent = 'Ë™çË≠ò‰∏≠...';

            const key = getApiKey();
            const fd = new FormData();
            const ext = mimeType.includes('webm') ? 'webm' : 'm4a';
            fd.append('file', blob, `audio.${ext}`);
            fd.append('model', 'whisper-1');
            fd.append('language', 'en'); // Ëã±Ë™û„Å®„Åó„Å¶Ë™çË≠ò

            try {
                const res = await fetchWithTimeout('https://api.openai.com/v1/audio/transcriptions', {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${key}` },
                    body: fd
                }, 30000);

                const data = await res.json();
                if (!data.text || data.text.trim().length === 0) {
                    statusText.textContent = 'Ë™çË≠ò„Åß„Åç„Åæ„Åõ„Çì„Åß„Åó„Åü';
                    setState(AppState.IDLE);
                    return;
                }

                const text = data.text.trim();

                if (!currentData.original) {
                    currentData.original = text;
                }
                currentData.final = text;
                transcriptArea.value = text;

                setState(AppState.CONFIRMING);
                statusText.textContent = 'Ë™çË≠òÁµêÊûú„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ';

            } catch (e) {
                statusText.textContent = e.name === 'AbortError' ? '„Çø„Ç§„É†„Ç¢„Ç¶„Éà' : '„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü';
                setState(currentData.original ? AppState.CONFIRMING : AppState.IDLE);
            }
        }

        async function processJapaneseCorrection(blob, mimeType) {
            setState(AppState.CORRECTING);
            statusText.textContent = '‰øÆÊ≠£ÊåáÁ§∫„ÇíËß£Êûê‰∏≠...';

            const key = getApiKey();
            const fd = new FormData();
            const ext = mimeType.includes('webm') ? 'webm' : 'm4a';
            fd.append('file', blob, `audio.${ext}`);
            fd.append('model', 'whisper-1');
            fd.append('language', 'ja'); // Êó•Êú¨Ë™û„Å®„Åó„Å¶Ë™çË≠ò

            try {
                // 1. Êó•Êú¨Ë™û„ÅÆ‰øÆÊ≠£ÊåáÁ§∫„ÇíË™çË≠ò
                const sttRes = await fetchWithTimeout('https://api.openai.com/v1/audio/transcriptions', {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${key}` },
                    body: fd
                }, 30000);

                const sttData = await sttRes.json();
                const instruction = sttData.text?.trim();

                if (!instruction) {
                    statusText.textContent = 'ÊåáÁ§∫„ÇíË™çË≠ò„Åß„Åç„Åæ„Åõ„Çì„Åß„Åó„Åü';
                    setState(AppState.CONFIRMING);
                    return;
                }

                // „Äå„ÇÇ„ÅÜ‰∏ÄÂõû„ÄçÁ≥ª„ÅÆ„Ç≠„Éº„ÉØ„Éº„Éâ„ÉÅ„Çß„ÉÉ„ÇØ
                if (instruction.includes('„ÇÇ„ÅÜ‰∏ÄÂõû') || instruction.includes('„ÇÑ„ÇäÁõ¥„Åó') ||
                    instruction.includes('„ÇÇ„ÅÜ1Âõû') || instruction.includes('ÊúÄÂàù„Åã„Çâ')) {
                    statusText.textContent = '„ÇÇ„ÅÜ‰∏ÄÂ∫¶Ëã±Ë™û„ÅßË©±„Åó„Å¶„Åè„Å†„Åï„ÅÑ';
                    setState(AppState.IDLE);
                    currentData.original = '';
                    currentData.final = '';
                    transcriptArea.value = '';
                    await startRecording(true);
                    return;
                }

                // 2. GPT„Åß‰øÆÊ≠£„ÇíÈÅ©Áî®
                statusText.textContent = '‰øÆÊ≠£„ÇíÈÅ©Áî®‰∏≠...';

                const gptRes = await fetchWithTimeout('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${key}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        model: 'gpt-4o-mini',
                        messages: [
                            {
                                role: 'system',
                                content: `You are helping correct an English sentence based on Japanese instructions.
The user will provide:
1. Current English text
2. Japanese correction instruction

Apply the correction and return ONLY the corrected English text, nothing else.
If the instruction is unclear, make your best interpretation.

Examples:
- "work„Åò„ÇÉ„Å™„Åè„Å¶walk" ‚Üí change "work" to "walk"
- "ÊúÄÂæå„Å´„Éî„É™„Ç™„Éâ„Å§„Åë„Å¶" ‚Üí add period at end
- "yesterday„ÇíÊ∂à„Åó„Å¶" ‚Üí remove "yesterday"`
                            },
                            {
                                role: 'user',
                                content: `Current text: "${currentData.final}"
Correction instruction: "${instruction}"`
                            }
                        ]
                    })
                }, 15000);

                const gptData = await gptRes.json();
                const corrected = gptData.choices[0].message.content.trim();

                currentData.final = corrected;
                transcriptArea.value = corrected;

                setState(AppState.CONFIRMING);
                statusText.textContent = `‰øÆÊ≠£ÈÅ©Áî®: "${instruction}"`;

            } catch (e) {
                statusText.textContent = '„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü';
                setState(AppState.CONFIRMING);
            }
        }

        async function processIntentRecording(blob, mimeType) {
            statusText.textContent = 'ÊÑèÂõ≥„ÇíË™çË≠ò‰∏≠...';

            const key = getApiKey();
            const fd = new FormData();
            const ext = mimeType.includes('webm') ? 'webm' : 'm4a';
            fd.append('file', blob, `audio.${ext}`);
            fd.append('model', 'whisper-1');
            fd.append('language', 'ja'); // Êó•Êú¨Ë™û„Å®„Åó„Å¶Ë™çË≠ò

            try {
                const res = await fetchWithTimeout('https://api.openai.com/v1/audio/transcriptions', {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${key}` },
                    body: fd
                }, 30000);

                const data = await res.json();
                const intent = data.text?.trim();

                if (!intent) {
                    statusText.textContent = 'Ë™çË≠ò„Åß„Åç„Åæ„Åõ„Çì„Åß„Åó„Åü';
                    setState(AppState.SUGGESTING);
                    return;
                }

                currentData.intentNote = intent;
                intentDisplay.textContent = `üí¨ ${intent}`;
                intentDisplay.style.display = 'block';

                // ÂÜçÊèêÊ°à„ÇíÂèñÂæó
                await getAISuggestion();

            } catch (e) {
                statusText.textContent = '„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü';
                setState(AppState.SUGGESTING);
            }
        }

        async function getAISuggestion() {
            setState(AppState.SUGGESTING);
            statusText.textContent = 'AI„ÅåËá™ÁÑ∂„Å™Ë°®Áèæ„ÇíËÄÉ„Åà„Å¶„ÅÑ„Åæ„Åô...';

            const key = getApiKey();
            const intentNote = currentData.intentNote;

            try {
                const systemPrompt = `You are a native English speaker helping a Japanese learner sound more natural and expressive.

Your task is to produce ONE enriched suggestion that achieves BOTH goals simultaneously:

Goal 1 ‚Äî Natural English:
- Rephrase to how a native speaker would naturally express the same idea
- Use natural idioms, phrasal verbs, and colloquial expressions where appropriate
- Fix grammar and unnatural word choices
- Keep the tone conversational but polite (suitable for acquaintances and colleagues)
- Avoid extreme slang (like "gonna", "What's up?") unless clearly appropriate

Goal 2 ‚Äî Add Volume & Expressiveness using these techniques:
- Relative clauses: add "who/which/that..." to elaborate on nouns (e.g. "the meeting that we had yesterday")
- Present participles: add "-ing" phrases to describe actions or circumstances (e.g. "feeling a bit overwhelmed, I decided to...")
- Descriptive modifiers: add adjectives, adverbs, or prepositional phrases that enrich the meaning (e.g. "really helpful", "at the last minute")

Apply at least one of the three volume techniques unless the sentence is already complex. The result should feel like something a fluent speaker would naturally say ‚Äî not artificially padded.

Return a JSON object with exactly these fields:
{
  "suggestion": "the enriched natural English expression",
  "explanation": "Êó•Êú¨Ë™û„Åß„ÄÅ‚ë†„Å©„ÅÜËá™ÁÑ∂„Å´„Åó„Åü„Åã„ÄÅ‚ë°„Å©„ÅÆË°®ÁèæÔºàÈñ¢‰øÇ‰ª£ÂêçË©û„ÉªÁèæÂú®ÂàÜË©û„Éª‰øÆÈ£æË™ûÔºâ„ÇíÂä†„Åà„Åü„Åã„ÇíÁ∞°Âçò„Å´Ë™¨ÊòéÔºà1„Äú2ÊñáÔºâ"
}

Rules for explanation:
- Write in Japanese
- Mention both the naturalness improvement AND what structural technique was added
- If no change was needed for one of the goals, focus on the other
- Keep it concise (1-2 sentences)

Return ONLY valid JSON, no markdown or extra text.`;

                let userPrompt = `Learner's English: "${currentData.final}"`;
                if (intentNote) {
                    userPrompt += `\n\nThe learner explained their intent in Japanese: "${intentNote}"
Please consider this context when suggesting a natural expression.`;
                }

                const res = await fetchWithTimeout('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${key}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        model: 'gpt-4o-mini',
                        messages: [
                            { role: 'system', content: systemPrompt },
                            { role: 'user', content: userPrompt }
                        ]
                    })
                }, 15000);

                const data = await res.json();
                const raw = data.choices[0].message.content.trim();

                let suggestion, explanation = '';
                try {
                    const parsed = JSON.parse(raw);
                    suggestion = parsed.suggestion;
                    explanation = parsed.explanation || '';
                } catch {
                    suggestion = raw;
                }

                currentData.aiSuggestion = suggestion;
                currentData.aiExplanation = explanation;
                suggestionText.textContent = suggestion;

                const explEl = document.getElementById('suggestionExplanation');
                if (explanation) {
                    explEl.textContent = explanation;
                    explEl.style.display = 'block';
                } else {
                    explEl.style.display = 'none';
                }

                statusText.textContent = 'AI„ÅÆÊèêÊ°à„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ';

                // TTSÂÜçÁîü
                await speakText(suggestion);

            } catch (e) {
                statusText.textContent = '„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü';
                currentData.aiSuggestion = currentData.final;
                currentData.aiExplanation = '';
                suggestionText.textContent = currentData.final;
            }
        }

        async function speakText(text) {
            const key = getApiKey();
            if (!key || !text) return;

            try {
                const res = await fetchWithTimeout('https://api.openai.com/v1/audio/speech', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${key}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        model: 'tts-1',
                        voice: 'alloy',
                        input: text
                    })
                }, 15000);

                const blob = await res.blob();
                await playAudioBlob(blob);
            } catch (e) {
                console.error('TTS error:', e);
            }
        }

        async function speakSuggestion() {
            await speakText(currentData.aiSuggestion);
        }

        // ===== Save Functions =====
        function saveToHistory(useSuggestion = true) {
            const h = JSON.parse(localStorage.getItem('soliloquyHistory') || '[]');

            const entry = {
                original: currentData.original,
                final: currentData.final,
                aiSuggestion: currentData.aiSuggestion,
                aiExplanation: currentData.aiExplanation || '',
                intentNote: currentData.intentNote || '',
                savedText: useSuggestion ? currentData.aiSuggestion : currentData.final,
                timestamp: Date.now(),
                notionSaved: false
            };

            h.unshift(entry);
            localStorage.setItem('soliloquyHistory', JSON.stringify(h.slice(0, 50)));

            renderHistory();
            resetToIdle();
            statusText.textContent = '‰øùÂ≠ò„Åó„Åæ„Åó„ÅüÔºÅ';
        }

        async function saveToNotion(index) {
            const h = JSON.parse(localStorage.getItem('soliloquyHistory') || '[]');
            const item = h[index];
            if (!item || item.notionSaved) return;

            const btnEl = document.getElementById(`notion-${index}`);
            btnEl.textContent = '...';
            btnEl.disabled = true;

            try {
                const res = await fetch('/api/notion', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        token: localStorage.getItem('notionToken'),
                        database_id: localStorage.getItem('notionDbId'),
                        original: item.original,
                        final: item.final,
                        aiSuggestion: item.aiSuggestion,
                        aiExplanation: item.aiExplanation || '',
                        intentNote: item.intentNote
                    })
                });

                if (!res.ok) {
                    const err = await res.json();
                    throw new Error(err.error || 'Failed');
                }

                item.notionSaved = true;
                localStorage.setItem('soliloquyHistory', JSON.stringify(h));
                btnEl.textContent = '‚úì';
                btnEl.classList.add('saved');
            } catch (e) {
                alert('Notion‰øùÂ≠ò„Ç®„É©„Éº: ' + e.message);
                btnEl.textContent = 'N';
                btnEl.disabled = false;
            }
        }

        function renderHistory() {
            const h = JSON.parse(localStorage.getItem('soliloquyHistory') || '[]');
            const nc = hasNotionConfig();

            if (h.length === 0) {
                historyList.innerHTML = '<div class="empty-state">„Åæ„Å†Â±•Ê≠¥„Åå„ÅÇ„Çä„Åæ„Åõ„Çì</div>';
                return;
            }

            historyList.innerHTML = h.map((item, idx) => `
                <div class="history-item">
                    <div class="history-item-header">
                        <div class="history-item-content">
                            ${item.original !== item.final ? `
                                <div class="history-label">Original</div>
                                <div class="history-original">${escapeHtml(item.original)}</div>
                            ` : ''}
                            <div class="history-label">Your English</div>
                            <div class="history-final">${escapeHtml(item.final)}</div>
                            <div class="history-label">AI Suggestion</div>
                            <div class="history-suggestion" onclick="speakHistoryItem(${idx})">${escapeHtml(item.aiSuggestion)}</div>
                            ${item.aiExplanation ? `
                                <div style="font-size: 12px; color: var(--text-secondary); margin-top: 2px;">${escapeHtml(item.aiExplanation)}</div>
                            ` : ''}
                            ${item.intentNote ? `
                                <div class="history-label">Intent</div>
                                <div class="history-original">${escapeHtml(item.intentNote)}</div>
                            ` : ''}
                        </div>
                        ${nc ? `
                            <button class="notion-btn ${item.notionSaved ? 'saved' : ''}"
                                    id="notion-${idx}"
                                    onclick="${item.notionSaved ? '' : `saveToNotion(${idx})`}"
                                    ${item.notionSaved ? 'disabled' : ''}>
                                ${item.notionSaved ? '‚úì' : 'N'}
                            </button>
                        ` : ''}
                    </div>
                </div>
            `).join('');
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        async function speakHistoryItem(index) {
            const h = JSON.parse(localStorage.getItem('soliloquyHistory') || '[]');
            if (h[index]) {
                await speakText(h[index].aiSuggestion);
            }
        }

        function clearHistory() {
            if (confirm('ÂÖ®„Å¶„ÅÆÂ±•Ê≠¥„ÇíÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü')) {
                localStorage.removeItem('soliloquyHistory');
                renderHistory();
            }
        }

        // ===== Event Listeners =====
        mainBtn.onclick = async () => {
            if (currentState === AppState.RECORDING) {
                stopRecording();
            } else if (currentState === AppState.IDLE || currentState === AppState.CONFIRMING) {
                await startRecording('english');
            }
        };

        btnVoiceCorrect.onclick = async () => {
            await startRecording('correction'); // Êó•Êú¨Ë™û„Åß‰øÆÊ≠£ÊåáÁ§∫
        };

        btnComplete.onclick = async () => {
            currentData.final = transcriptArea.value.trim();
            if (!currentData.final) {
                alert('„ÉÜ„Ç≠„Çπ„Éà„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ');
                return;
            }
            await getAISuggestion();
        };

        btnRetry.onclick = () => {
            resetToIdle();
        };

        btnAccept.onclick = () => {
            saveToHistory(true);
        };

        btnKeepOriginal.onclick = () => {
            saveToHistory(false);
        };

        btnResuggestion.onclick = async () => {
            await startRecording('intent'); // Êó•Êú¨Ë™û„ÅßÊÑèÂõ≥„ÇíË™¨Êòé
        };

        // Manual editing
        transcriptArea.addEventListener('input', () => {
            if (currentState === AppState.CONFIRMING || currentState === AppState.CORRECTING) {
                currentData.final = transcriptArea.value;
            }
        });

        // ===== Initialization =====
        window.onload = () => {
            // Load saved settings
            const savedKey = localStorage.getItem('apiKey');
            if (savedKey) document.getElementById('apiKey').value = savedKey;

            const savedNt = localStorage.getItem('notionToken');
            if (savedNt) document.getElementById('notionToken').value = savedNt;

            const savedNd = localStorage.getItem('notionDbId');
            if (savedNd) document.getElementById('notionDbId').value = savedNd;

            // Save settings on input (immediately)
            document.getElementById('apiKey').addEventListener('input', e =>
                localStorage.setItem('apiKey', e.target.value));
            document.getElementById('notionToken').addEventListener('input', e =>
                localStorage.setItem('notionToken', e.target.value));
            document.getElementById('notionDbId').addEventListener('input', e =>
                localStorage.setItem('notionDbId', e.target.value));

            // Render history
            renderHistory();
            updateUI();
        };
    </script>
</body>
</html>
